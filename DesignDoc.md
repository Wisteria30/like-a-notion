0. ドキュメント概要★

本ドキュメントは、Notionクローンアプリケーションの設計仕様書です。一人のエンジニアが本設計に基づき実装を行うことを想定しており、プロダクトの背景・哲学から詳細な技術設計、非機能要件、テスト計画、ロードマップまでを網羅します。主な読者は当該実装を担当するエンジニアおよびレビューを行う関係者であり、ドキュメントは開発初期に作成・合意した後は原則固定し、重要な変更発生時にADR(決定記録)へ追記する更新方針とします。

本クローンの目的は、チーム向けのコラボレーションツールとしてNotionと同等のブロック型ノートアプリを構築することです。MVP範囲の全機能を一括実装しウォーターフォール的にリリースする計画であり、スケジュールとリスクを考慮しつつ「まずシンプルに作り、必要に応じてスケールさせる」アプローチ ￼ ￼を採用します。以下、各章で要求と解決策を詳細に設計します。

1. 背景と哲学

背景: 従来のクラウドドキュメントではページ（文書）が情報の最小単位であり、情報がファイルやフォルダの中に閉じ込められていました ￼。Notionはこの制約を打破し、あらゆる情報を細かなブロック単位で扱うことでユーザーが自由に情報を組み合わせ、再構成できるように設計されています ￼。ブロックは情報を扱う原子的な要素であり、ユーザー自身がレゴブロックのように組み立てて、自分専用のワークスペースを構築できる柔軟性を提供します ￼。このように、情報を粒度の細かいブロックとして扱う独自のデータモデルがNotionの柔軟性の根幹です ￼。

プロダクト哲学・UX原則: Notionの哲学は「オールインワンのワークスペース」を掲げ、メモ、ドキュメント、Wiki、タスク管理、データベースなど従来は別々のツールで管理していた情報を一元化することにあります ￼。シンプルなテキストエディタとしての手軽さと、高度にカスタマイズできる拡張性を両立し、「簡単に使い始められるが、使いこなすと強力」というUXを実現しています ￼。これは “easy to learn, hard to master” の思想であり、シンプルさによる低い参入障壁と、ブロックの組み合わせによる高度な表現力を両立しています ￼。また機能追加に際しては、「少なくても質の高い機能」を優先し既存機能の改善を重視するポリシーを採っています ￼。このため、本プロダクトもMVPではコア機能に集中し、将来的な拡張はユーザーの実利用状況を見て検討する方針です。

2. ゴール／非ゴール★

ゴール（MVPで必ず満たすもの）:
	•	ブロックベースのページ編集: テキスト、見出し、リスト、チェックボックス、画像埋め込み等の基本ブロックをページ上で作成・編集できること。ブロックのドラッグ＆ドロップ並び替えや階層構造（インデントによる入れ子）に対応します。
	•	ページ及びデータベース: 階層化されたページ管理（ページの中にサブページを作成可能）と、簡易的なデータベース機能（例えばテーブルビューでのアイテム一覧管理）を提供します。データベースは項目ごとにユーザー定義プロパティ（タグ、日付など）を持つページの集合体として実装します ￼。
	•	リアルタイム共同編集: 複数ユーザーが同時に同じページを開き編集できるコラボレーション機能を備えます。編集内容は即座に他の参加者画面に反映され、オンラインでの共同作業体験を提供します（詳細は後述のリアルタイム同期設計を参照）。
	•	権限管理と共有: ワークスペース内のページを他ユーザーと共有し、閲覧専用・コメント可・編集可などのアクセス権を設定できます。ワークスペースメンバー全員に共有、特定ユーザー・ゲストに個別共有、公開リンクによる閲覧（MVPではオプション）などNotionに近い柔軟な共有設定を目指します。各ページ以下のブロックは基本的にそのページの権限を継承し、適切にアクセス制御されます ￼。

非ゴール（今回扱わない範囲）:
	•	スプレッドシート相当の高度な計算機能: ExcelやGoogleスプレッドシートのようなセル単位の計算、複雑な数式機能は実装しません。Notionが提供するような簡易な**プロパティ計算（合計・カウントや簡単な四則演算程度）**は将来的な拡張とし、MVPでは優先度を下げます。
	•	外部サービスとの統合: カレンダーやSlackとのリアルタイム連携、Webhook、自動化Bot等の外部連携機能はMVP範囲外とします（手動でのデータインポート程度に留める）。
	•	モバイルアプリ・オフライン動作: 当面はWebブラウザでのデスクトップ利用をターゲットとし、ネイティブアプリやオフライン完全対応は行いません。オフライン編集については将来的にCRDTを活用する余地がありますが、MVPでは常時オンライン環境下での利用を前提とします。
	•	高度なUI演出: UI/UXは基本的な使い勝手を優先し、アニメーションや高度なテーマカスタマイズ等の演出面は簡易な実装に留めます。例えばドラッグ＆ドロップ時のプレビューや、ブロックタイプごとの凝ったビジュアルは将来の改善項目とします。

以上の範囲に絞ることで、MVPとしてブロック編集・ページ管理・共同編集というコア価値を確実に提供することに注力します。追加機能はMVPリリース後のフィードバックに基づき段階的に導入します。

3. 主要ユースケース & ペルソナ★

本プロダクトはチーム利用を念頭に置いており、複数の代表的なペルソナのユースケースを想定しています。それぞれの「ジョブ (Job-To-Be-Done)」を明確にし、機能要件に反映します。
	•	ペルソナA: プロジェクトマネージャー（チームリーダー）
シナリオ: プロジェクトマネージャーのAliceは、チームのプロジェクト計画書を本ツールで作成・共有します。彼女はページをプロジェクトごに階層構造で整理し、タスクの進捗をチェックリストやデータベース（タスク一覧テーブル）で管理します。リアルタイム共同編集により、チームメンバーと同時にページを編集し議事録を作成します。
ジョブ: チームの情報を一元管理し、誰でも最新状況を閲覧・更新できる共同作業スペースを提供すること ￼。例えば「プロジェクトロードマップ」のページではメンバーが自由にコメントや修正を行い、常に最新の計画を全員が共有します。
	•	ペルソナB: エンジニア（個人利用＋チームナレッジ共有）
シナリオ: エンジニアのBobは、個人の技術メモやコードスニペット集を本ツール上に整理します。同時にチームのWiki担当として、他のエンジニアと共同でナレッジベースページを編集します。彼はMarkdownライクな入力で素早くメモを残し、後でページを再編成して体系化します。
ジョブ: 柔軟なナレッジ管理とドキュメントの共同編集 ￼。個人メモからチーム共有Wikiまで、ブロックを使って自由に構造化できることで、「まずアイデアを箇条書きで書き出し→後から整理」といった逐次的な知識蓄積を可能にします。
	•	ペルソナC: デザイナー（タスク＆データ管理）
シナリオ: デザイナーのCarolは、本ツール上でデザインリソースの管理ページを運用します。ページにはデザインガイドラインや画像の埋め込み、UIパーツの一覧（データベース）を含め、チームメンバー（エンジニアやPM）と共有しています。またタスク管理ボードもページ内に作成し、進捗をカンバン方式で可視化します。
ジョブ: 異なる情報タイプの一元管理。テキスト説明、画像、タスクボード、データベースなどを一つのページに統合できることで、コンテキストを切り替えることなく情報閲覧・編集ができます ￼。Carolはリンクや埋め込みブロックを活用し、デザイン関連情報を関連付けて管理します。

以上のように、ユーザーは簡単なチェックリスト作成からビジネスの詳細なプロジェクト管理まで、用途に応じて使い方が成長・発展していくことが期待されます ￼。この柔軟性を支えるため、本プロダクトはブロックの再利用性とページの階層構造、コラボレーションを軸に設計されます。

4. コア機能

MVPで実装する主要機能を概説します。Notionクローンとして必須となる機能群であり、これらを中心に設計・実装を行います。
	•	ブロックエディタ（リッチテキスト編集）: ページ上でブロック単位にコンテンツを編集するエディタ機能です。ユーザーは/コマンドやUIボタンから新規ブロックを挿入でき、段落、見出し、箇条書きリスト、チェックリスト、引用、コードスニペット、画像埋め込みなど多様なブロックタイプを選択可能です ￼。各ブロックはドラッグによる並べ替えや、左右インデントによる階層変更（子ブロック化/解除）をサポートします。エディタは直感的なUI（+ボタンやハンドルアイコン等）でブロック操作を可能にし、Markdown記法入力（例: - でリスト、#で見出し 等）による効率的な編集も検討します。
	•	ページ管理: ページはブロックの集合体として実装され、サイドバーにページツリーを表示します。ページ間は階層構造を持ち、入れ子のサブページを無制限に作成可能です。ユーザーはツリー上でページの作成、移動、ドラッグによる階層変更を行えます。各ページには固有のURL（UUID）を割り当て、リンク共有や参照が可能です ￼。ページ遷移時には内容を即座に表示できるよう、クライアント側にキャッシュされたブロックを利用しつつ、変更差分はリアルタイム同期で適用します。
	•	データベース（テーブルビュー）: ページの一種としてデータベース機能を提供します。データベースページは内部に複数のエントリ（行）を持つテーブルの形で表示されます。各エントリは通常のページ（ブロック集合）として表現しつつ、一覧性のために指定したプロパティ（列）を表示します。例えば「タスク管理」データベースでは、各行がタスク詳細ページに相当し、列として「担当者」「期限」「ステータス」等のプロパティを持ちます。このようなユーザー定義プロパティはブロックのプロパティ機構上に実装し、柔軟なデータ構造を実現します ￼。MVPではビューのバリエーション（カンバン、カレンダー等）はテーブルビューのみに絞りますが、データの並び替え・絞り込み機能は提供します。
	•	リアルタイム共同編集: 複数ユーザーが同じページを開いた際、各利用者の編集操作をリアルタイムに同期します。具体的には、WebSocketによるサーバープッシュを用いて、あるユーザーの編集内容（ブロックの追加・削除・テキスト変更など）を他のユーザーのクライアントに即座に反映させます。Notionではクライアントが編集中のブロックに対して変更購読を行い、サーバーの更新通知を受け取る仕組みです ￼。本クローンでも各クライアントがWebSocket接続を張り、関心のあるページまたはブロックの更新イベントを購読します。更新が発生すると、サーバーは該当するクライアントに差分データまたは新しいブロック状態を送信し、クライアント側で画面を更新します ￼。また編集箇所に他ユーザーのカーソル位置や名前の表示（プレゼンス機能）も可能な範囲で実装します。
	•	コメント・履歴（将来拡張枠）: MVPでは必須ではありませんが、Notionのようにブロックやページにコメントを付けたり、ページの変更履歴を保存・閲覧する機能は将来的に有用です。変更履歴については、ブロックのバージョン管理を行い、主要な変更をスナップショットとして保存する方法が考えられます ￼。コメント機能は各ブロックに紐づくコメントスレッドを持たせるデータ構造で設計可能です。これらはMVPの範囲外としつつ、アーキテクチャ上大きな制約とならないよう拡張性を考慮します。

5. コア概念

本章では、設計上重要な概念とモデルについて整理します。

ブロックモデル（階層・型・拡張）

ブロックとは: Notionと同様、本クローンにおけるすべてのコンテンツ要素は「ブロック」として定義されます。テキスト段落、箇条書き、画像、埋め込み、ページそのものさえも一律にブロックとして扱われます ￼。ブロックは一貫した内部構造を持ち、以下の主要属性で構成されます ￼:
	•	ID: 各ブロックにはユニークなID（UUID v4）が付与されます ￼。このIDはURLでのページ参照や、ブロック間リレーションのキーとして用いられます。
	•	タイプ: ブロックの種類を表すフィールドです。例: paragraph, heading, todo, image, page, database 等。ブロックタイプにより表示方法や保持するプロパティが異なります ￼。ユーザーは後からブロックの種類を変更（「Turn into」機能）できますが、その際もブロックID自体は不変で、中身のプロパティは可能な限り保持されます ￼。例えば、チェックリストブロックをHeadingブロックに変更すると「完了チェック」のプロパティは一時的に無視されますが、再びチェックリストに戻せば元のチェック状態が復元されます ￼。この設計により、ブロック種別変更時もユーザーの意図（例えばチェック済みか否か）を最大限保全します。
	•	プロパティ: ブロックが持つ内容データやメタデータです。代表的なプロパティはテキスト系ブロックのtitle（テキスト内容）であり、他にもToDoブロックのchecked（完了フラグ）、画像ブロックのcaption（キャプション）などタイプ毎に固有のプロパティを持ちます ￼。またページブロック（特にデータベース内のページ）はユーザー定義のプロパティを複数持つことができ、それらもこのプロパティ構造の中で管理されます ￼。実装上、プロパティはJSONフィールドで柔軟に保持し、共通プロパティ（title等）は列として持ちつつ、カスタム項目はJSON内にシリアライズする方針です。
	•	コンテンツ（子ブロック配列）: ブロックが内包する子ブロックのIDリストです ￼。例えばページブロックは、そのページ内に配置されたトップレベルブロック（段落や画像等）のID配列をcontentプロパティとして持ちます。また箇条書きブロックは、入れ子になった子リスト項目のブロックIDをcontent配列で管理します。content配列に含まれるブロックは表示上もそのブロックの下位にレンダリングされます（DOMツリーに対応）。この配列順序がブロックの表示順序となります。
	•	親（上位参照）: ブロックの親要素を指す参照です ￼。親は通常「このブロックを含む直近の上位ブロック」または「ワークスペース/root」です。親がページブロックの場合、そのページのcontent配列に自分のIDが含まれることを意味します。親参照は各ブロックが一意の木構造に属することを保証するために使われ、パーミッション（権限継承）の計算にも利用します ￼。

以上のモデルにより、ブロックは**有向非循環グラフ（DAG）**構造を形成します。特にループを避け単一親ポインタとすることで、ブロックツリーを上方向・下方向に効率よく走査できます。Notionでも親ポインタと子配列のペアでツリーを構成しており、ブロックが複数箇所から参照される事態は避けています ￼ ￼。MVPではこの単純化された木構造に従い、ブロックの複製は物理的に別IDのブロックを生成するものとします（将来的に同一ブロックを複数ページで参照する「リンクトデータベース」のような機能は別途検討）。

パーミッション（Workspace / Page / Block）

ワークスペース: 複数ユーザーが属するコラボレーション単位であり、本クローンでは1つのワークスペース内に全ページが存在します（MVPではシングルワークスペース前提）。ワークスペースにはメンバー（社内ユーザー）とゲストを含めたユーザーが所属し、ワークスペース全体に適用されるロール（権限）が存在します。例えば「Workspace Owner（管理者）」「Member（メンバー）」「Guest（ゲスト）」の役割です ￼。オーナーはメンバー招待や設定変更が可能、メンバーは基本的に全ての非限定ページを閲覧編集可能、ゲストは招待された特定ページのみアクセス可能といった区分です ￼ ￼。ワークスペースは論理的なルートノードでもあり、各ページブロックの親として機能します（ページ階層の最上位は親がWorkspace）。

ページ共有と権限: 各ページ（ブロック）はデフォルトでは作成者のみアクセス可能なプライベートです ￼。ユーザーがページを共有すると、そのページに対して他ユーザーまたはグループに「閲覧 (Can View)」「コメント (Can Comment)」「編集 (Can Edit)」「フルアクセス (Full Access)」のいずれかの権限レベルでアクセス権が付与されます ￼ ￼。これら設定はACL（Access Control List）的にページごとに保存します。共有されたページはサイドバーの「Shared」セクションに一覧表示されます ￼。なお、あるページを共有するとその配下のすべての子ページ・子ブロックにも権限が継承されます ￼。例えばタスクデータベースページを閲覧可で共有すれば、その中の各タスク（子ページ）も自動的に閲覧可となります。ただし親ページとは別に子ページ単体を追加共有することも可能で、非公開ページ内に存在するサブページだけ個別に外部共有するケースにも対応します（Notionでも特定サブページのみゲスト招待可能）。この場合、上位ページにアクセス権を持たないユーザーでも直接リンクを知っていればそのサブページにアクセスできますが、当然上位ページの内容は閲覧できません。

ブロックレベルの権限: Notionでは基本的にページ単位での権限管理ですが、実装上は各ブロックが親ブロックの権限を継承する形でアクセスチェックを行います ￼。ブロックモデルの設計段階で、当初は一つのブロックが複数の親コンテナ（content配列）から参照される可能性がありましたが、それでは「どの親の権限を適用すべきか」曖昧になる問題があります ￼。従って前述の通り親ポインタは単一であり、各ブロックは明確に一つの親ブロック（またはワークスペース）を持ちます ￼。これにより権限判定の際はブロックから親を再帰的に辿って最上位（ワークスペース）までの権限継承をチェックすればよくなります。具体的には、あるユーザーがブロックBを編集可能か確認するには、ブロックB自身または祖先ページでそのユーザーに編集権限が与えられているかを確認します。もし祖先のいずれにも権限がなければアクセス不可となります。実装上は、権限チェックのためにブロックからrootまで親参照をトラバースし、各段階でACLを確認します。この処理を効率化するため、ブロックごとに上位ページIDやワークスペースIDを持たせキャッシュしておく拡張も将来的に検討します（ただし更新時の整合性管理が必要）。

アクセス変更の伝播: ページのアクセス権を変更した際（共有設定変更時）は、その配下の全ブロックに対して新たな権限が適用されます。例えばページPを「閲覧可」でゲスト共有した場合、P配下のすべてのブロックは閲覧可能とみなされます。この伝播はリアルタイムで行われ、必要に応じて現在ページを開いているユーザーのUIにも変更が反映されます。設計上は、ACL変更時に当該ページを開いている他ユーザーにWebSocket経由で通知し、クライアントで権限ラベルの更新や閲覧可否の切り替えを行います（MVPでは簡略化し、変更後に再読み込みすれば反映とする場合もあります）。いずれにせよ一貫した権限モデルを維持するため、サーバー側で全ての読み書きリクエストに対し適切な権限チェックを組み込みます。

6. テクノロジースタック

本プロダクトはNext.js (React) + TypeScriptを主軸に開発します。要求される柔軟性と実装効率、また最新のWeb開発ベストプラクティスを考慮し、以下の技術スタックを選定しました。
	•	フロントエンド: Next.js (React + TypeScript)
Next.jsはSSR(サーバーサイドレンダリング)やルーティング機能を備えたReactフレームワークであり、シングルページアプリケーションの性能とSEOを両立できます。UIはReactコンポーネントベースで実装し、状態管理には軽量なZustandやRedux Toolkitを必要に応じて使用します。リッチテキストエディタ部分はProseMirrorもしくはその高レベルラッパーであるTiptapを組み込み、ブロック単位の編集UIを実現します ￼。ProseMirrorはNotion類似の協調編集エディタを構築する実績があり、カスタマイズ性も高いです。スタイリングはTailwind CSS等のユーティリティCSSフレームワークを用いて迅速に構築します。
	•	バックエンド: Node.js (TypeScript) + Express または Next.js API Routes
バックエンドはシンプルなRESTful APIサーバーとして実装します。Node.js上でExpressフレームワーク（またはNext.js組み込みのAPIルート）を利用し、認証、ページ・ブロックCRUD、リアルタイム通信等のエンドポイントを提供します。アプリケーションロジックはモノリシックにまとめ、まず単一のデプロイ可能ユニットとして実装します。Notion自身も当初はRailsモノリス＋単一Postgresで開始し、スケールに応じて段階的に拡張しています ￼ ￼。モノリスは開発・デプロイが簡単で、小規模チームには有利なため、本プロダクトもまずモノリスで構築します。後述するように、スケールに応じてDBのシャーディング等で対応し、不要な早期のマイクロサービス化は避けます ￼。
	•	データベース: PostgreSQL
データストアにはリレーショナルDBであるPostgreSQLを採用します。PostgresはNotion本家でも使用されており、ブロックデータを一貫したスキーマで格納する基盤となっています ￼。リレーショナルモデルにより参照整合性を確保しやすく、複雑なクエリ（例えば特定ワークスペース内での検索など）にも柔軟に対応できます。ブロックやページ、ユーザー、ACLなどのエンティティを正規化してテーブル設計します。一方、Notion同様に各ブロックのプロパティやコンテンツJSONをPostgresで保持するため、JSONBカラムや全文検索インデックス (GINインデックス) の活用も視野に入れます ￼。小規模では1インスタンスで充分ですが、将来的にはワークスペース単位のシャーディングで水平スケーリング可能な構成です ￼。
	•	リアルタイム基盤: WebSocket + CRDTライブラリ
共同編集のリアルタイム同期にはWebSocketを使用します。サーバー上でWebSocketサーバーを立ち上げ、各クライアントと双方向通信を行います。同期アルゴリズムにはCRDT (Conflict-Free Replicated Data Type) の利用を検討しています。具体的にはYjsライブラリを導入し、ブロックツリーまたはテキストの変更をCRDTでマージ可能なopsとして扱います ￼。Yjsは高性能なCRDT実装であり、自動で変更をマージしコンフリクトを解消できる共有データ型を提供します ￼。WebSocket上ではYjsの更新メッセージ（Update）を送受信し、各クライアントの文書状態（ブロックツリー）を常に最終一致させます。Yjsの利点は中央集権的なサーバによる順序決定が不要な点で、順不同に適用しても最終状態が収束する保証があります ￼。MVPではサーバーを経由したブロードキャスト型同期としつつ、将来的なオフラインモードではサーバー非依存でのピアツーピア同期も視野に入れます。
	•	認証認可: OAuth 2.0 + JWT + RBAC
認証はセキュリティとユーザビリティの両面から、GoogleやGitHubなどのOAuth 2.0ログインをサポートします。Next.jsの場合、NextAuthなどを利用して主要プロバイダ経由のシングルサインオンを実装可能です。また自前のメールアドレス+パスワードログインも実装し、選択肢を提供します。認証後のセッション管理にはJWT(Json Web Token)を用いて、クライアントからのAPIリクエストにAuthorizationヘッダ経由でトークンを送信、サーバーで検証します。認可(RBAC)としては前述のWorkspaceロール（オーナー・メンバー・ゲスト）およびページ単位のアクセス権を統合的に判断します。各APIエンドポイント実行時に、要求する操作に必要な権限（例えばページ編集APIならそのページへの編集権）がトークン内のユーザーにあるかチェックします。これにより堅牢なアクセス制御を実現します ￼。なお、管理者向け機能（監査ログ閲覧等）はEnterprise相当の将来機能とし、MVPではシンプルに実装します。
	•	インフラ・デプロイ: Dockerコンテナ + ローカル or クラウド（想定）
開発環境およびデプロイにはDockerコンテナを利用し、アプリケーションサーバーとPostgresをコンテナ化します。ローカル環境ではDocker Composeで容易に起動・テストできるようにし、将来的なクラウド展開（AWS ECS/EKSやVercel等）も見据えます。ログや環境変数の管理にはdotenvやシークレットマネージャを使用します。MVP段階ではローカルデプロイ前提ですが、本番相当ではコンテナイメージをCIでビルドし、テスト後にレジストリにプッシュ、CDでデプロイというパイプラインを構築します。

以上のスタック選定は、最新の技術トレンドも踏まえつつ安定性・開発生産性を重視しています。「インフラには枯れた技術を選び、革新はエディタ部分で行うべし」という提言にも沿っています ￼。TypeScript全般で型安全性を担保しつつ、ReactによるリッチUIとCRDTによる先進的な同期モデルを組み合わせることで、堅実かつ革新的なアプリを目指します。

7. 全体アーキテクチャ★

本章ではシステム全体の構成を説明します。MVPではシンプルなクライアント・サーバーアーキテクチャを採用し、必要なコンポーネントを一通り実装します。デプロイ構成はローカル環境（単一マシン上）を基本とし、クラウドデプロイも容易に拡張できるよう設計します。

コンポーネント図: 下記に本システムの主要コンポーネントと関係を示します（簡易的な図表として記述）。
	•	Client (Next.js Reactアプリ): ブラウザ上で動作するフロントエンド。UIレンダリング、ユーザー操作処理、API呼び出し、WebSocket接続管理を行う。各ユーザーのブラウザごとにインスタンスが存在。
	•	Sub-component: Block Editor UI（ProseMirrorベース）、State Management (React Context/Recoil等)
	•	Web Server (Node.js + Express/Next API): クライアントからのHTTPリクエストを処理するバックエンドアプリケーション。REST APIエンドポイント群を提供し、認証、ページ・ブロックCRUD、検索、ファイルアップロード等を処理する。サーバー内でドメインロジックを実行し、DBとのやりとりを行う。
	•	Module: Auth Module (OAuth認証フロー, JWT発行)、Page/Block Module (CRUDロジック, パーミッションチェック)、Database Module (SQLクエリ発行) など。
	•	WebSocket Server: リアルタイム更新のためのサーバー。上記Web Serverと同プロセス内で動作させる（例えば同じNodeアプリ内でWSライブラリを利用）か、別途WS専用サーバーを立ててWebServerと連携する。各クライアントとの間で双方向通信を維持し、ドキュメント更新メッセージを配信する。スケーラビリティを考慮し、必要に応じてスケールアウト可能な構成（将来的にはRedis等でPub/Subし複数ノード間配信する構成）も検討。MVPでは単一ノード上で完結。
	•	Database (PostgreSQL): 永続データストア。全てのブロック、ページ、ユーザー、権限情報等を格納する。スキーマ詳細は次章参照。MVPでは単一インスタンスで稼働し、接続もシンプルに一系統。アプリサーバーから直接SQLクエリまたはO/Rマッパー(Prisma/TypeORM等)経由で操作。
	•	Tables: users, workspaces, pages, blocks, block_properties, permissions, etc.
	•	External Services (OAuth Providers, Storage etc): OAuth認証にGoogle等を使う場合の外部プロバイダ、および画像などファイルを扱う場合のS3等ストレージ。MVPでファイルはDBにバイナリ格納またはローカル保存でも可。メール通知（共有リンク送付等）が必要ならばメールサーバー連携も将来検討。

デプロイ構成: ローカル環境では上記のWebサーバー、WSサーバー、DBを同一マシン上で起動します。Next.js開発サーバーを利用しつつ、NodeサーバーとPostgresをDocker Composeなどで連携させる形です。プロダクションデプロイを見据えるなら、WebサーバーとWSサーバーは同じNodeプロセスにまとめるか（シンプルなためMVPではこの方式）、必要に応じて分離してスケールさせます。例えば将来的に大規模化した場合、アプリサーバー（REST API）とリアルタイムサーバーを分離デプロイし、双方がDBと共有メッセージキュー（Redis等）で連携する構成を取れます。しかしMVP段階では一つのNode.jsアプリにRESTとWSの両機能を実装し、シングルホスト上でPostgresとともに稼働する構成です。

システムはクライアント->サーバー->DBの同期的な通信路と、サーバー->クライアントの非同期WS通信路を持ちます。クライアントはまずHTTPでページデータを取得し、その後WSで変更を受け取るというハイブリッド通信になります ￼。コンポーネント同士のインターフェースは以下の通り:
	•	Client <-> WebServer: HTTP(S) + JSON (REST API)
	•	Client <-> WS Server: WebSocket + JSON/バイナリ (CRDT更新)
	•	WebServer <-> Database: SQL (TCP接続)
	•	WebServer <-> OAuth Provider: HTTPS (OAuth2 flows)

このようにして、シンプルなモノリシック構成の中にリアルタイム通信を組み込んだアーキテクチャとなっています。Notionがマイクロサービスに傾倒せずモノリシックな設計を保ったことで俊敏な開発と高いパフォーマンスを両立したのと同様、本プロダクトもまずはモジュラーなモノリスとして構築します ￼。

8. データモデル & スキーマ★

本章では、主要なデータエンティティとデータベーススキーマ設計について記述します。MVPに必要なエンティティを洗い出し、リレーショナルモデルでのER図および各テーブルのスキーマ概要を示します（ER図は文末付録参照を想定）。

主なエンティティ:
	•	User（ユーザー）: ワークスペースに参加する利用者。フィールド: id (UUID), name, email, auth_provider（認証方法）, role（ワークスペース内ロール: Owner/Admin/Member/Guest）など。ユーザーとワークスペースは多対多（ユーザーは複数ワークスペースに属し得る）が、MVPでは1ワークスペース前提のためワークスペースIDをUserに持たせてもよい。
	•	Workspace（ワークスペース）: コンテンツ（ページ）の最上位コンテナ。フィールド: id, name, owner_user_idなど。MVPでは1ワークスペースのみ想定のため簡易化する可能性あり。Workspaceはルートページを親として持ちます。
	•	Page（ページ）: ドキュメントまたはデータベースを表すブロック。Page自体もBlockの一種ですが、DB設計上は利便のためpagesテーブルを独立させます（これはAPI上でのPageオブジェクト表現に対応）。フィールド: id (UUID), workspace_id, parent_page_id (NULLable), title, icon, cover_image, is_database（データベースか否か）など。parent_page_idがNULLの場合はワークスペース直下のトップレベルページ。データベースの場合、別途schema定義への参照を持つ。
	•	Block（ブロック）: ページ内の構成要素。基本はblocksテーブルで全ブロックを保持します。フィールド: id (UUID), page_id（このブロックが属するページ。トップレベルブロックの場合そのページ、入れ子ブロックも所属ページ自体は同じになる）, parent_block_id (NULLable)（直近の親ブロック。トップレベルブロックはNULLもしくは親ページをparent_blockとして扱う）、type（ブロック種別）, index（兄弟ブロック内での順序）など。content配列は明示的なカラムとしては持たず、親子関係（parent_block_idとソート順index）で表現します。各ブロックのデータ本体（テキスト内容等）は別途プロパティテーブルまたはJSONBカラムで管理します。
	•	BlockProperty（ブロックプロパティ）: ブロックごとのプロパティ。実装方針により、blocksテーブルにJSONBフィールドpropertiesとしてまとめてもよいですが、クエリしやすさのために主要なプロパティをカラムに持つ可能性もあります。MVPでは柔軟性重視でproperties JSONに全プロパティを格納します。例えばParagraphブロックなら{"text": "Hello World"}, ToDoブロックなら{"text": "Task1", "checked": false}, Pageブロックなら{"title": "Project Doc", "icon": "📄"}のように。
	•	DatabaseSchema（データベーススキーマ）: データベースページの場合、その中のアイテム（ページ）が持つユーザー定義プロパティの型定義リストを保持します。フィールド: id, page_id（対応するデータベースページID）, schema_json（プロパティ名・型の定義JSON）。例: タスクDBなら{“Status”: “select”, “DueDate”: “date”, “Assignee”: “person”}など。MVPではシンプルに文字列型か選択肢型程度。
	•	Permission（権限設定）: ページ共有のACL情報。フィールド: id, page_id, user_idまたはgroup_id, role（閲覧/コメント/編集/フルアクセス）。ワークスペース全員共有や公開リンクの場合はuser/groupではなくプリセットの対象(例えばuser_id = NULLか特別値)で表現します。ブロック単位の権限はページで一括管理するため、基本的にこのテーブルのみで充分です。
	•	その他: 参照用にWorkspaceMembership（ユーザーとワークスペースの関係）やGroup（ユーザーグループ）テーブル、AuditLog（重要操作の記録）なども考えられますが、MVPでは簡略化のため実装しないか1ワークスペース内前提で省略します。

スキーマ設計例: （主要テーブルのDDLを簡略表示）

```SQL
-- users
CREATE TABLE users (
  id UUID PRIMARY KEY,
  name TEXT,
  email TEXT UNIQUE,
  role TEXT CHECK (role IN ('owner','admin','member','guest')),
  auth_provider TEXT,
  ...,
  created_at TIMESTAMP, updated_at TIMESTAMP
);

-- workspaces
CREATE TABLE workspaces (
  id UUID PRIMARY KEY,
  name TEXT,
  -- single workspace assumption: might not be heavily used in MVP
  created_at TIMESTAMP
);

-- pages (also represents database if is_database = true)
CREATE TABLE pages (
  id UUID PRIMARY KEY,
  workspace_id UUID REFERENCES workspaces(id),
  parent_page_id UUID REFERENCES pages(id),
  title TEXT,
  icon TEXT,
  cover_image TEXT,
  is_database BOOLEAN DEFAULT FALSE,
  created_by UUID REFERENCES users(id),
  created_at TIMESTAMP, updated_at TIMESTAMP
);

-- blocks
CREATE TABLE blocks (
  id UUID PRIMARY KEY,
  page_id UUID REFERENCES pages(id),
  parent_block_id UUID REFERENCES blocks(id),
  type TEXT,            -- e.g. 'paragraph', 'todo', 'image', 'page'
  sort_index INT,       -- order among siblings
  properties JSONB,     -- content and inline properties (text, checked, etc.)
  created_at TIMESTAMP, updated_at TIMESTAMP
);

-- If separating page content from page properties:
-- page content basically blocks where parent_block_id IS NULL and page_id = that page (top-level blocks)

-- database schema (for custom properties in database pages)
CREATE TABLE database_schema (
  page_id UUID PRIMARY KEY REFERENCES pages(id),
  schema JSONB           -- e.g. { "Status": "select", "DueDate": "date", ... }
);

-- permissions (ACL for page sharing)
CREATE TABLE permissions (
  id SERIAL PRIMARY KEY,
  page_id UUID REFERENCES pages(id),
  user_id UUID REFERENCES users(id),   -- null if not user-specific (e.g. "everyone")
  role TEXT CHECK (role IN ('view','comment','edit','full'))
);
```

インデックス設計: 各テーブルには検索やJOINのための適切なインデックスを付与します。例えば、blocks.page_idやblocks.parent_block_idにはインデックスを張り、あるページ内のブロック一覧取得や親から子の検索を高速化します。permissions.page_idやuser_idにも複合インデックスを付与し、ページごとのアクセス許可確認を効率化します。JSONBのプロパティ内を検索する場合（例：特定テキストを含むブロック検索）は、GINインデックスをpropertiesフィールドに作成することで全文検索を可能にします。

ER図: （※付録に図示予定） 全体的にはUsers -< Workspaces -< Pages -< Blocksというツリー構造と、Pages -< PermissionsによるACL、Pages -< DatabaseSchemaの関連があります。ブロック同士は自己参照でツリーを形成します。Notionのデータモデルでは200億を超えるブロックが単一スキーマで格納されており ￼、本クローンもその流儀に倣ってスキーマを統一的・正規化的に設計しています。

9. API 設計★

クライアントとサーバーの通信にはREST APIを採用します。GraphQLやgRPCも検討しましたが、シンプルなリソース指向と広い馴染みを優先しRESTfulに設計します。Notion公式APIもRESTベースであり、学習コストが低い利点があります。特に、クライアント(JavaScript)からはfetchによるHTTP通信で容易に扱え、またOpenAPIで定義することでドキュメント生成や型生成も可能です。

選定理由:
	•	REST: CRUDに対応したリソース指向な設計が可能で、本アプリのページやブロックといった実体に自然にマッピングできます。エンドポイントが直感的で、HTTPメソッドで操作を表現できるため開発生産性が高いです。特に一人開発かつクライアントも自分で実装する場合、RESTはシンプルでデバッグしやすい利点があります。
	•	GraphQL: 柔軟なクエリが可能ですが、サーバー・クライアント双方の実装負荷が増大します。例えばページ取得時に関連ブロックや権限情報を一度に取得する場合GraphQLは便利ですが、MVP段階ではエンドポイントを適切に用意すれば十分対応可能です。したがって導入は見送りました。
	•	gRPC: バイナリプロトコルによる高パフォーマンスが利点ですが、主にサービス間通信向けであり、ブラウザから直接使うにはgRPC-web等が必要になります。リアルタイム通信は別途WebSocketを使うため、REST+WebSocketで必要要件を満たせると判断しました。

主要エンドポイント一覧: （OpenAPIによる詳細定義を別途添付予定。以下は概要）
	•	認証系:
	•	POST /auth/login : OAuthコードを受け取りJWTを発行、またはメール・パスワードを検証しJWT発行。
	•	POST /auth/logout : （必要なら）サーバー側セッション無効化（JWT利用時はクライアント側でトークン破棄のみ）。
	•	GET /auth/user : 現在の認証ユーザー情報を取得（プロフィール、ワークスペース所属など）。
	•	ユーザー・ワークスペース系:
	•	GET /workspace/members : ワークスペースのメンバー一覧取得（権限や招待状況含む）。
	•	POST /workspace/invite : メンバー招待（メール送信などはMVPでは省略しトークン発行だけ）。
	•	（ワークスペース管理APIは最小限。MVPでは単一WS想定のため省略も可）
	•	ページ (Page) 系:
	•	GET /pages : トップレベルページの一覧取得（サイドバー表示用）。
	•	POST /pages : 新規ページ作成（親を指定してサブページも可能）。リクエストボディにparentPageId（またはworkspaceId）、title等を含む。
	•	GET /pages/{pageId} : ページ詳細取得。ページブロック自体のプロパティ（タイトル、アイコン等）および直下のブロック一覧（子ブロックIDリスト）を返す。【※注: Notion APIではページ取得はプロパティのみで、内容は別エンドポイントですが【26†L9-L16】、本APIでは利便のためある程度含めてもよい】
	•	PUT /pages/{pageId} : ページのプロパティ更新（タイトル変更など）。
	•	DELETE /pages/{pageId} : ページ削除（またはアーカイブ扱い）。
	•	ブロック (Block) 系:
	•	GET /pages/{pageId}/blocks : 特定ページ内の全ブロックツリー取得。階層構造をネストしたJSONで返すか、平坦なリスト＋親子関係で返す。ブロック数が多い場合ページングも検討（MVPでは一括）。
	•	POST /pages/{pageId}/blocks : 新規ブロック追加。ボディにparentBlockId（nullならトップレベル）、type, propertiesを含む。生成されたブロックIDを返す。
	•	PUT /blocks/{blockId} : ブロック内容更新。ボディに変更したいpropertiesフィールドのみ含め部分更新。ブロックの移動（親変更・順序変更）もこのAPIでparentBlockIdやindex更新として扱う。
	•	DELETE /blocks/{blockId} : ブロック削除。子ブロックもまとめて削除される（論理削除とするか物理削除とするかは要検討：MVPでは物理削除）。
	•	データベース (Database) 系:
	•	GET /databases/{pageId} : データベース（ページ）のスキーマとエントリ一覧を取得。スキーマはカラム定義JSON、エントリ一覧は各エントリのプロパティ（title含む）を簡略化して返す。大量の場合はページング。
	•	POST /databases/{pageId} : （エントリ追加）データベースに新規エントリ（新規ページ）を追加。プロパティ値をボディで受け取り、ページ作成APIを内部的に呼ぶ。
	•	PATCH /databases/{pageId}/schema : （オプション）データベースのスキーマ変更（プロパティの追加・削除・変更）。
	•	権限・共有 (Permissions) 系:
	•	GET /pages/{pageId}/permissions : ページの現在の共有設定取得（誰にどの権限か）。
	•	POST /pages/{pageId}/permissions : ページ共有の追加。ボディにuserOrEmail, role等。指定ユーザーまたは招待メール宛に閲覧/編集権付与。
	•	PUT /pages/{pageId}/permissions/{permId} : 既存の共有権限の更新（例: 閲覧権限を編集権限に昇格）。
	•	DELETE /pages/{pageId}/permissions/{permId} : 共有解除。
	•	リアルタイム・コラボレーション系:
	•	GET /pages/{pageId}/subscribe : （※WebSocketで実装するためHTTPではなく説明用）ページの変更イベントをサブスクライブ開始。WebSocket接続を確立し、このページの更新（ブロック変更、コメント追加等）をリアルタイム受信。
	•	WebSocketメッセージ種別: block-update, block-delete, block-add などイベントタイプとブロック内容をペイロードに含め配信。また presence（ユーザー入退室通知）等も送る。

OpenAPIドキュメント: OpenAPI 3.0に従い上記エンドポイントとリクエスト/レスポンスモデルを定義します。開発者はこのドキュメントを参照することでAPI仕様を把握できます。（具体的なOpenAPI YAML/JSONは省略）

エラーハンドリング: 共通して、バリデーションエラーや認可エラーには適切なHTTPステータスコードとエラーメッセージ(JSON)を返します。例えば認証切れには401 Unauthorized、権限不足には403 Forbidden、存在しないリソースアクセスには404 Not Found、バリデーションエラーには400 Bad Requestなど。クライアントではこれらをハンドリングし、UI上にフィードバックします。

認可チェック: API層でJWTのユーザー情報をもとに、対象リソースのアクセス権を確認します。例えばPUT /blocks/{id}リクエストなら、そのブロックが属するページでユーザーが編集権限を持つか検証します。権限はPermissionテーブルを引いて確認するか、JWTに予め権限クレームを入れる設計も考えられます（後者は変更反映が遅れるので基本都度照会）。このようにサーバー側で強制することで、不正な操作をブロックします。

全体として、REST APIによりクライアントから典型的な操作（ページ作成・編集・閲覧共有など）ができるように設計しました。エンドポイントの設計はリソース指向かつ直交性（各エンドポイントがそれぞれの責務に専念）を意識しており、Notion非公式APIや類似サービスの設計も参考にしています ￼。

10. シーケンス図

主要なユースケースについて、クライアント・サーバ・DB間のシーケンス（処理の流れ）を記述します。ここでは代表的なシナリオである ①ページ読み込み, ②ブロック編集 & リアルタイム同期, ③アクセス権変更 のシーケンス図（時系列のやりとり）を文章で説明します。

① ページ読み込み

シナリオ: ユーザーがページのURLにアクセスし、そのページ内容が表示されるまで。
	1.	HTTPリクエスト: ユーザーAliceがブラウザでページURL (/pages/{id})を開くと、クライアントはまずサーバーに対しGET /pages/{id}APIを呼び出します。認証JWTをヘッダに付与し、ページ基本情報と直下のブロック一覧を要求します。
	2.	サーバ処理: Webサーバーは受け取ったリクエストを認証・認可チェックします（そのユーザーがそのページを閲覧可能かPermissionsテーブル照会）。問題なければPagesテーブルからページを取得し、Blocksテーブルからpage_id = {id} AND parent_block_id IS NULLのブロック一覧を取得します。さらに、各ブロックのプロパティ（テキスト等）も取得し、JSON構造を生成します（必要に応じ子孫ブロックも再帰取得するか、初回ロードではトップレベル＋直下の子まで取得し、深い階層は遅延ロードでも可）。
	3.	HTTPレスポンス: サーバーはページ情報（タイトル等）とブロックツリーJSONをレスポンスとして返します。例えば:

```json
{
  "id": "page123", "title": "Project Plan",
  "blocks": [
    {"id": "b1", "type": "heading", "properties": {"text": "Plan"}},
    {"id": "b2", "type": "todo", "properties": {"text": "Task1", "checked": false}},
    {"id": "b3", "type": "paragraph", "properties": {"text": "Details..."},
      "children": [
         {"id": "b4", "type": "image", "properties": {"url": "..."}}
      ]
    }
  ]
}
```

のような構造です。ブロックb3には子ブロックb4がある例。

	4.	クライアント表示: クライアントは受け取ったデータをもとにReactでページをレンダリングします。各ブロックタイプに対応するコンポーネントで内容を表示し、ユーザーが編集可能なようにエディタ状態を構築します。例えばProseMirrorの場合、サーバーからのブロックJSONをドキュメントノード構造に変換します。
	5.	WebSocket購読開始: ページ表示後、クライアントはWebSocket接続を確立します。サーバーのMessageStore（リアルタイムサービス）に「page123に関する更新を自分(Alice)に通知する」よう購読登録します ￼。これにより、同ページ編集中の他ユーザーの変更があればWS経由で通知を受け取れる準備が整います。

以上により、ユーザーの画面には最新のページ内容が表示され、以降のリアルタイム更新受信体制も完了します。

② ブロック編集 & リアルタイム同期

シナリオ: 2人のユーザー（AliceとBob）が同じページを共同編集する様子。Aliceがページに新しいブロックを追加し、その変更がBobにも反映される流れ。
	1.	ローカル編集: Aliceがページに「ToDoリストの新規項目」を追加するため、エディタ上でEnterキーを押します。クライアント上ではまずローカルで新しいブロックオブジェクト（例: {id: "temp123", type: "todo", properties: {"text": ""}}）を生成し、現在のページデータ構造に挿入します ￼。この時点でAliceの画面には新規の空チェックボックスが即座に表示されます（楽観的UI更新）。さらにブロックの一意ID(UUID)を発行し、必要な初期属性（親ブロックへの紐付け等）も設定します ￼。この一連の変更はトランザクションとしてクライアント内に記録されます ￼。
	2.	ローカルキャッシュ更新: クライアント（Alice側）は自身のメモリ/IndexedDB上のキャッシュに新規ブロックを追加し、エディタ表示を更新済みです ￼。また、変更操作（ブロック追加）の情報を操作キューに積みます。NotionのクライアントではこれをTransactionQueueで管理し、未送信のトランザクションを保持します ￼。本クローンでも類似の仕組みで、送信前の操作を一時保存します。
	3.	サーバー送信: クライアントは変更を即座にサーバーへ送信します。具体的にはPOST /pages/{id}/blocksAPIを呼び、ボディに新ブロックデータ（親IDや内容）を含めます。複数の変更操作をまとめて行った場合は、Notionのように/saveTransactionsで一括送信も考えられますが ￼、MVPでは一操作1リクエストで処理します。CRDTを採用している場合は、クライアント側で差分Updateを計算し、WebSocket経由でサーバーに送る実装も可能です。その場合サーバーはそれを受け取りDB保存するだけで衝突解決は不要となります ￼。ここではシンプルさのためサーバーが最終合意を決定する方針（LWWに近い）で説明します。
	4.	サーバー処理（保存）: サーバーはAliceから受け取った新規ブロック追加リクエストを処理します。まず認可チェックを行い、Aliceがそのページに編集権限を持つことを確認します。次に、トランザクションを開始し、データベースに対し以下を実行します ￼:
	•	Blocksテーブルに新ブロックレコードをINSERT（ID、タイプ、親参照、プロパティ等）。
	•	親ブロックまたは親ページのcontent（子リスト）を更新します。設計上content配列は暗黙的にsort_indexで管理しているため、例えば同じ親を持つブロックの最大index+1を新ブロックindexに設定してINSERTします。ページ直下の場合はpagesテーブルの子リストを直接更新する代わりに、blocksでparent_block_id=NULLで管理しているためこの処理は不要かもしれません。
	•	変更適用後、整合性チェック（親子関係が循環していないか、権限的に許される挿入か等）を行い問題なければCOMMITします ￼。
	5.	サーバー処理（通知）: データベース更新が成功すると、サーバーはリアルタイム通知のための処理を行います。具体的には、該当ページを購読中のクライアントをMessageStoreで特定し、「ブロックが追加された」イベントと新しいブロックデータを送る準備をします ￼。MVPではシンプルにMessageStore内に変更内容を保存しておきます。
	6.	HTTPレスポンス: サーバーはAliceのAPI呼び出しに対し、成功ステータス(200 OK)と追加されたブロックの正式データ（確定したIDなど）を返します。Aliceのクライアントはこれを受け取り、自身の一時IDを正式IDに置き換えるなどの調整を行います。またトランザクションキューからこの操作を削除します ￼。
	7.	リアルタイム通知配信: サーバーはWebSocket経由で、同ページを開いている他のユーザー（ここではBob）のクライアントに対し更新通知を送信します ￼。具体的には、メッセージ種別block-addと新規ブロックのデータを含むJSONを送ります。
	8.	他クライアント反映: BobのクライアントはWebSocketからの通知を受信すると、自身の状態と比較します。まだローカルに存在しないブロックIDであるため、/syncRecordValuesAPIでその最新データをサーバーに問い合わせる（または通知内に十分な情報があればそれを直接使用する）形で同期します ￼。同期後、Bobの画面にもAliceが追加したToDoブロックが即座に表示されます。Bobが何も操作していなければ自動でレンダリングに追加され、もし編集中だった場合でもCRDTで位置をマージするなどして整合します。
	9.	確認と継続: AliceとBob双方の画面に新ブロックが表示され、以降そのブロックへの編集も同期されます。例えばAliceが新ブロックにテキスト入力をすると、その度に差分がサーバー配信されBob側も更新します。Notionではブロック単位で変更を扱うため、各段落は競合が起きにくくなっています ￼。

この一連の流れにより、ユーザー間でストレスのない共同編集が実現されます。なお、ネットワーク分断などで一時的に同期できなくても、CRDTを使う場合は再接続時に自動マージされます。Notion本家では従来サーバー優先のLWW方式でしたが、オフライン編集対応のためCRDTへの移行を進めているとのことです ￼。

③ アクセス権変更

シナリオ: ページ所有者のAliceが、そのページをBobとCharlieに共有し、Bobには編集可、Charlieには閲覧のみ権限を与える操作。
	1.	操作開始: Aliceはページの「共有」ボタンを押し、共有ダイアログでユーザーBob（既存メンバー）に「Can Edit」、ユーザーCharlie（ゲスト、メール招待）に「Can View」を設定します。
	2.	APIコール（編集権限付与）: クライアントはPOST /pages/{id}/permissionsをBob用に呼び出し、{"user": "Bob", "role": "edit"}を送信します。続いてCharlie用に{"email": "charlie@example.com", "role": "view"}を送信します。
	3.	サーバー処理: サーバーはAliceがそのページの管理者（所有者orフルアクセス権）であることを確認します。次にPermissionsテーブルにそれぞれレコードを挿入します（既存あれば更新）。Bobのケースではuser_idをBobのIDで、roleをeditで保存。Charlieの場合はユーザー登録が無ければ仮の招待状態とし、メールアドレス紐づけや招待トークン発行も行います（MVPでは簡易に、ゲストエントリをUsersに作成してpermissionsに紐づける）。
	4.	通知処理: サーバーは共有対象ユーザーが現在オンラインか確認します。Bobは既にワークスペースメンバーでオンラインなら、彼のクライアントに対し「新しくページXへのアクセス権(edit)が与えられた」通知をWebSocket等で送ることも可能です。MVPではそこまでせず、Bob自身が次回ページ一覧取得した時に反映されれば良いとします。一方Charlieにはメール招待を送信します（招待リンクによりアカウント作成/ログイン後、そのページにアクセス可能になる）。
	5.	HTTPレスポンス: 各API呼び出しに対し成功を返します。クライアント側ではUI上で「共有済み」と表示を更新します。
	6.	クライアント反映: Bobのクライアントは、もしAliceがページを「ワークスペース内公開」にした場合などはサイドバーにページが現れたりします。今回は個別共有なので、Bobは共有通知を受け取るか、もしくは次にページ一覧をリロードした際に新規Sharedページとして見えるでしょう。Charlieはメール内のリンク経由でアクセスした際、認証後にページが開けます。またその後は自分のSidebarにそのページがSharedページとして表示されます。
	7.	リアルタイム効果: すでにそのページを閲覧中だったユーザーには、権限変更によりUIに変化がある場合があります。例えばAliceがCharlieにビュー権を与えた直後、Charlieが同ページを開いていれば（稀なケースですが招待直後に開いたとか）、編集UIが無効化され「閲覧のみ」表示になる、といった対応が考えられます。MVPでは細かい動的対応はせず、ページ再読み込みで反映でも許容します。

この操作により、アクセス権限（ACL）が更新されページの可視範囲が広がりました。以降Bobは当該ページに編集リクエスト（PUT/POST）が可能となり、CharlieはGETはできても編集APIを呼ぶと403になる、といった挙動になります。権限変更は頻繁ではないですが、セキュリティ上非常に重要な操作であるため、今後監査ログに残す等の措置も検討します。

以上三つのシーケンス図シナリオを通じて、本システムの動作フローを理解できたかと思います。全体として、クライアントの操作がサーバーAPI経由でDBに記録され、必要に応じてリアルタイム通知が配信される構造になっています。処理の一貫性・整合性を保つために、サーバー側でトランザクション境界をしっかり管理し（複数ブロック変更はまとめてコミット）、クライアント側では一時データのロールバックも考慮した実装となります ￼。

11. 詳細設計

ここではモジュール単位の詳細設計について記載します。ブロックエディタ、リアルタイム同期、認証認可など重要部分ごとにアーキテクチャやアルゴリズムの詳細を説明します。

11.1 ブロックエディタ

ブロックエディタは本プロダクトのUIにおける核となる部分です。Notion同様の直感的なブロック操作を実現するため、以下の設計方針と技術を採用します。
	•	エディタエンジン: 前述の通り、ProseMirrorベースのエディタを使用します。ProseMirrorはドキュメントモデルをJSONで保持し、トランザクションで変更を管理できるエンジンです。Notionのような自由なブロック移動やネストにも適応しやすく、さらにコラボレーティブ編集にも対応可能です。実装にはProseMirrorをReactで包んだTiptapエディタフレームワークを利用し、ブロックごとのノードスキーマを定義します。各ブロックタイプ（paragraph, heading, list_item, todo_item, image, etc）はProseMirrorのノードとして定義し、必要なフィールド（attrs）を持たせます。例えばToDoアイテムならattrs: { checked: Boolean, text: String }のようにします。
	•	入力操作とキーバインド: エディタは標準的なMarkdownライクの操作をサポートします。Enterで新規ブロック作成、Backspaceで空ブロック削除または親とのマージ、Tab / Shift+Tabでブロックのインデント変更（リスト等で階層移動）、/キーでブロックメニュー表示、といったキーバインドを実装します。ProseMirrorではキーマップを定義してこれらの操作に対応できます。例えばEnter押下時に、現在の位置がブロック末尾なら新規同種ブロックを挿入、チェックリストならチェック状態引き継ぎ等のカスタム挙動を組み込みます。
	•	ブロック階層構造操作: ブロックのドラッグ＆ドロップによる移動、親子関係の変更（インデント/アウトデント）を実装します。ドラッグ＆ドロップはブラウザのHTML5 DnD APIまたはライブラリ（React DnD等）を用いて、ブロック要素をドラッグした際にゴースト表示し、ドロップ位置で順序や親を更新します。内部的には対応するブロックノードのparent_block_idとsort_indexを更新し、エディタ状態・DBに反映します。インデント/アウトデントは現在のブロックを一つ上のリスト項目の子にする/外す操作で、前提として直前の兄弟が存在するか等を判断します ￼。Notionでは前のブロックがリストでない場合インデントしても何も起きない仕様ですが ￼、本クローンでも同様のルールを適用します。実装的には、ProseMirrorノードのリフトやラップ操作（liftNode, wrapIn）を使ってブロックツリーを変更します。
	•	ブロックタイプ変換: 「Turn into」機能、すなわち既存ブロックのタイプ変更も対応します。例えばテキスト段落をToDoに、ToDoをHeadingに変える等です。設計上、ブロックIDは変えずにtypeを更新し、不要になったプロパティは保持したまま隠し、再度タイプを戻した際に復元できるようにします ￼。例えばToDo→Headingではchecked属性を無視しつつ保持、Heading→ToDoに戻すと以前のchecked値を復元します ￼。これはブロックモデルの柔軟性の利点であり、実装では各ブロックノードが全属性を保持し、表示時にタイプに応じて使うものだけ使うアプローチを取ります。
	•	レンダリング: 各ブロックはReactコンポーネントで描画します。例えばParagraphブロックはプレーンなにテキスト、Headingは〜等のタグ、ToDoは＋テキスト、とします。ProseMirrorのビュー層カスタマイズを行い、ノードタイプごとにReactコンポーネントに紐付けます。これにより、DOM更新はReactが担い、ProseMirrorは文書構造と選択状態管理に専念します。スタイルシートでブロック間のマージンやインデントは適切に設定し、ネスト構造はpaddingやborderで視覚的に示します。チェックボックスやドロップダウン（選択肢プロパティの編集UI）などのインタラクティブ要素も組み込みます。
	•	埋め込み・メディア: 画像ブロックは<img>で表示し、クリックでファイル選択ダイアログ→アップロード→表示といった流れを組み込みます。MVPでは画像はBase64エンコードしてblocks.propertiesに入れてもよいですが、ファイルサイズの観点で別途ファイルストレージにするか検討します。動画やウェブブックマーク埋め込みは非対応とします（テキストとしてリンク表示程度）。
	•	ローカルキャッシュ: エディタでロードしたページのブロック構造はIndexedDBにも保存し、次回アクセス時にオフラインでも直前状態を見ることも技術的には可能ですが、MVPでは常時オンライン前提なので強い要件ではありません。ただ、NotionではWASM SQLiteを使いクライアントキャッシュすることでページ遷移高速化を図っています ￼。本クローンでもページデータをメモリに保持し、別ページ移動後戻ってきた際に再取得を待たず即表示するなどUX向上を図ります。

以上、ブロックエディタは直感的な操作感とデータモデル整合の両立が重要です。特にドラッグ＆ドロップやインデント操作でツリー構造を壊さないよう検証を行います。また、ユーザーの入力操作をできるだけ妨げずスムーズに反映するために、複雑な処理はバックグラウンド（例えばサーバ送信は非同期）で行い、UIは常に即時応答するようにします。

11.2 リアルタイム同期 (CRDT / OT)

リアルタイム共同編集の要は同時編集によるコンフリクトをいかに扱うかです。本クローンではCRDT (Conflict-Free Replicated Data Type) のアプローチを採用し、可能な限り自動マージを行います。ただし実装複雑度を鑑み、MVP時点では簡易なサーバー主導のマージ（Last-Writer-Wins）に留め、段階的にCRDTへ移行する計画とします。
	•	同時編集の課題: 典型的には、AliceとBobが同じ段落を同時に編集した場合、最終的な文書がどのようになるか決定する必要があります。従来のGoogle Docs等はOT (Operational Transform) により、操作（例えば「位置5に文字Xを挿入」）を転送し整合させています。一方CRDTは各クライアントが持つ状態を論理タイムスタンプ等でマージする戦略です。Notionは2023年時点までテキストに関してCRDTを使わずサーバーでの最終書き込み勝ち (LWW) 方式でした ￼。つまり衝突が起きた場合はサーバーが時間順に勝者を決め、負けた変更は上書きされます。この方式だとオフライン時の変更反映に課題があります ￼。そこで本クローンではオフラインも見据え、原理的にコンフリクトを整合できる**CRDT(Yjs)**を組み込みます。
	•	CRDT (Yjs)の統合: Yjsはテキスト用の共有タイプ（Y.Text）やマップ、配列を提供し、自動マージ可能です ￼。本クローンでは各ブロックを一つの要素とみなし、ページ全体を表すYjsドキュメントを構築します。例えばページ内のテキストブロックはY.Textとして扱い、ブロック間はY.Arrayで順序管理します。ブロック削除・追加はY.Array上の要素操作、テキスト編集はY.Text上の操作となります。Yjsは各変更を「Update」としてエンコードでき、これをWebSocketで配信します。各クライアントがUpdateを受け取ると自分のYjsドキュメントにapplyUpdateすることで、自動的に変更が反映されます ￼ ￼。
	•	サーバの役割: 完全なP2P同期も可能ですが、MVPではサーバーがハブになります。各クライアントから受け取ったYjs Updateをそのまま他の全クライアントにブロードキャストし（or差分転送）、かつサーバー自身も一つのYjsドキュメントインスタンスを保持して常に最新状態を適用し続けます。一定時間ごと、またはユーザー操作終了時にサーバー上のYjsドキュメントの状態をデータベースに保存します。この方法だとサーバーが単一障害点になりますが、Update自体は順不同で適用可能なので、冗長構成も取れます ￼。
	•	LWWからCRDTへの移行: 初期実装ではサーバーに依存したLWWでも大きな問題は起きにくいよう工夫します。例えばNotionがそうであったように、**一つのブロック内のテキスト編集は非常に短い粒度（1ブロック＝1段落）**に区切ります ￼。これにより、真にコンフリクトが起きるのは同一段落に複数人が同時にタイプした場合だけで、その確率は比較的低くなります ￼。仮に起きてもLWWで1〜2キー分の入力が負ける程度でユーザーが手で再調整できるという思想です ￼。MVPではまずこの形で実装し、オフライン編集が必要になった段階でCRDTを本格運用するようにします（Notionもまさにその方向 ￼）。
	•	実装詳細: WebSocket上のメッセージフォーマットは、LWW方式なら{type: "edit", blockId: X, newValue: "foo", version: 123}等で送り、受信側が自分のバージョンより新しければ適用、古ければ破棄する、といった単純なものにします。CRDT方式ならYjsのupdate（Uint8Arrayバイナリ）をBase64等でエンコードし送信します。双方対応できるようプロトコルバージョンを設けても良いでしょう。クライアントではProseMirrorのコラボプラグインか、直接Yjsにドキュメントバインドする方法でエディタと同期します。例えばY.Textにエディタ内容をミラーリングし、remote update時にはエディタに変化を適用、local change時にはupdate生成という具合です。
	•	競合の視覚化: 万一競合が発生した場合、基本CRDTなら自動マージですが、その結果文意が壊れる可能性があります。簡易策として、競合時に変更箇所をハイライト表示しユーザーに通知する方法があります。しかしMVP範囲では対応しません。ノートツールでは競合自体あまり多発しないとの知見もあります ￼。極端な場合、最近の変更を優先しつつ、失われた変更はページ履歴から拾えるようにする運用も考えられます（Notionはバージョン履歴機能があります ￼）。
	•	パフォーマンス: CRDTは状態が肥大化しがちという課題があります。YjsはGarbage Collection等の機構も備えますが、長期間大量編集するとUpdateが重くなる可能性があります。MVP期間の小規模利用では問題になりませんが、テストとして数千ブロック規模のページや100以上の同時接続でも動作を検証します。問題が顕在化したら、差分同期範囲の限定（画面上見えているブロックのみとか）や、定期的なドキュメント再同期（スナップショット＆再JOIN）などを検討します。
	•	Fallback: もしCRDT実装に致命的バグがあった場合は、最悪編集のロックという手段も考えます。他ユーザー編集中の段落にはインジケータを出し入力制限するなどです。Quipなど旧来コラボツールはその方式でしたがUX低下が大きいため非推奨です ￼。本クローンでは基本ロック無しで進めます。

以上、リアルタイム同期は**「常に同じ内容が全員に見えている」**ことを保証するのが目的です。CRDTにより各ピアが最終的に同じ状態に収束する（Conflict-Free）ことが理論上保証されます ￼。Notionエンジニアも「並行編集に必ずしもCRDTは不要」とコメントしつつも、オフライン対応にはやはりCRDTが有効だと述べています ￼。本プロダクトも将来的なオフラインモードや分散編集に備え、CRDT技術の適用を視野に入れて設計しています。

11.3 認証認可 (OAuth + RBAC)

認証認可モジュールでは、ユーザーのログイン・ログアウト、および各APIリクエストに対するアクセス制御を扱います。セキュアで使いやすい認証を提供しつつ、細かな権限管理を実現する設計です。
	•	OAuth2 + OpenID Connect: 現代的なSaaSと同様、GoogleやGitHubアカウントでログインできるようOAuth2認証フローを実装します。NextAuthなどを利用すると、クライアント側でプロバイダへのリダイレクト→コールバック受信→JWT発行まで簡潔に実装できます。サーバー側ではコールバックエンドポイント(/api/auth/callback/google等)を用意し、プロバイダから受け取ったIDトークンを検証してユーザー情報を取得します。既存ユーザーでなければUsersテーブルに作成し、ログインセッションを確立します。クライアントにはJWT（またはHttpOnlyクッキーセッションID）を付与します。MVPでは簡単のためJWTをアクセストークンとして発行し、クライアントで保持します。
	•	パスワードログイン: 内部ユーザー向けにメールアドレスとパスワードでのログインも可能にします。これはUsersテーブルにハッシュ化パスワードを保持し、/auth/loginで照合します。ハッシュはbcrypt等で行い、安全性を担保します。パスワードリセットやメール検証等はMVPでは省略します。ビジネス用途ではSSOを使うことが多い前提で、こちらは補助的手段です。
	•	JWT発行と管理: JWTにはユーザーID、名前、ロール、トークン有効期限等を含め署名します。短期間（例:1時間）で失効し、長期間のログイン維持にはリフレッシュトークン（長寿命のランダム文字列）を別途発行して再取得する流れを検討します。ただMVPではシンプルにして、アクセストークンが切れたら再ログインさせる運用でもよいでしょう。JWTは各APIリクエストのAuthorizationヘッダに付与され、サーバーで検証されます。検証には公開鍵/共有鍵を用い、改ざんや偽造を防ぎます。クライアント側ではログアウト時にこのトークンを破棄します。
	•	RBACモデル: Role-Based Access Controlとして、前述のWorkspaceロールとPage権限を組み合わせて認可判断します。実装としては二段階チェック:
	1.	ワークスペースレベル: ユーザーがそもそもシステムにおいてどの権限範囲か。Owner/Adminなら全操作許可、Memberならほとんど許可、Guestなら制限多といった具合 ￼。例えばGuestは自分に共有されたページしかアクセスできないため、リクエストのページIDが自分のアクセスリストに無ければ即拒否します ￼。
	2.	ページレベル: Workspaceで許されていても、対象ページごとのACLを確認します。Permissionsテーブルをクエリし、そのユーザーIDまたは所属グループに対応するエントリを探します。該当すればロール（view/comment/edit/full）を取得し、要求アクションと照らし合わせます。例えばrole=viewの人がPOST/PUT/DELETE系エンドポイントを叩いたら許可せずエラーとします。role=commentならコメント追加APIは許可するがブロック編集は拒否、といった実装です。Fullなら共有変更も許可します。
RBAC判断ロジックはAPIルートごとに共通化します（ミドルウェアまたはデコレータでチェック）。ページ読み込みや検索も、ユーザーがアクセスできるページのみ結果返却するようクエリに組み込みます。
	•	ゲストとメンバーの処遇: Guestユーザー（社外の閲覧者など）はWorkspaceには属さず個別ページACLのみ持つため、Workspaceロールとしては特別扱いになります ￼。ゲストは基本Memberより制限が強く、新規ページ作成不可・他人招待不可等をシステム上で強制します ￼。実装的にはUsersテーブルにrole=‘guest’を設定し、UI上も機能を絞ります。
	•	管理者機能: Workspace OwnerやAdminは全ページの閲覧権限を持つ（Notion Enterpriseでは管理者がプライベートページも閲覧可能な設定があります ￼）場合があります。MVPではそこまで実装せず、Ownerでも他人の非共有ページは見れない仕様とします。ただしOwnerは他人のページも共有設定を変更できる、といった拡張は考えられます。RBAC上はOwner判定があれば許す特殊ケースを入れることになります。
	•	セキュリティ考慮: 認証認可周りは攻撃に対して堅牢にします。具体的には、JWTの機密保持（HTTPS必須、XSS対策としてHttpOnlyクッキー利用も検討）、OAuthのリダイレクトURL検証、パスワードログインではログイン試行回数制限やCAPTCHA導入検討、などです。APIでは認可漏れがないよう全てのエンドポイントでユーザー権限チェックを行います（例えばGET /blocks/{id}でも、そのブロックの属するページ閲覧権がなければ404または403を返す）。これにより、権限のないデータが推測やID操作で漏洩しないことを保証します。
	•	パフォーマンス: 認可チェックのために毎回DBクエリするのは多少の負荷になります。最適化として、ユーザーがアクセス可能なページ一覧（もしくはページ→最大権限）をログイン時にキャッシュし、JWTに含める手もあります。ただACL変更がリアルタイム反映されない恐れがあるため、MVPでは全リクエスト都度確認で構いません。インデックスを適切に貼ればユーザーごとページ権限検索も高速です。

まとめると、本モジュールによりシングルサインオンの利便性ときめ細かなアクセス制御が両立します。Notionも無料プランではゲスト制限、エンタープライズでは管理者権限の微調整など多層の認可があります ￼ ￼。本クローンでも将来的な拡張を見据えて、ユーザーロールとページACLの二軸でコントロールする仕組みを構築しています。

… （他のモジュール詳細設計もこのように続く）

12. 非機能設計★

非機能要件として重要な項目について、設計上の考慮事項を述べます。本プロダクトは小規模チーム向けですが、将来的な成長も見据えて信頼性・保守性・セキュリティ・パフォーマンスなどに配慮します。
	•	ロギング: サーバーサイドでは、各リクエストや重要なイベントをログ出力します。具体的には、APIエンドポイントのアクセスログ（メソッド、URL、ユーザーID、処理時間）、エラー発生ログ（スタックトレース）、権限エラー発生時の情報（ユーザーと対象リソース）などを含みます。ログはJSON形式で構造化し、開発中はコンソール出力、本番ではファイルまたはログ集約基盤（ELKスタックやクラウドのCloudWatch等）に送ります。機密情報（パスワード等）はログに残さないよう注意します。クライアント側でも、エディタの致命的エラーやWebSocket切断などはユーザー通知するとともにTelemetryサーバーに送信してトラブルシューティングに役立てます。
	•	モニタリング: 稼働中のシステム指標をモニタリングします。サーバーではCPU・メモリ使用率、DB接続数、レスポンスタイム、エラーレート等を監視します。Next.js/Node.jsではPrometheusメトリクスを導入したり、NewRelicやDatadog APMを組み込んで、特にAPI毎のレイテンシやクエリ性能を可視化します。リアルタイム関連ではWebSocketの接続数やメッセージ送受信レートも計測します。またDB側でもクエリスロークエリログを有効にし、必要ならインデックス追加等チューニングします。
	•	アラート: モニタリング指標に閾値を設定し、異常時に通知を発します。例えばサーバーエラーレート5%以上、レスポンスタイム平均1秒超、メモリ80%超などでSlackやメールにアラート送信します。特にデータ消失や権限漏洩につながりかねないエラー（例: DB接続失敗やPermissionチェックのバグ）は即時にエスカレーションできるようにします。
	•	スケーラビリティ: 現状は単一ノード構成ですが、将来的には水平スケールを可能にします。StatelessなAPIサーバーであれば、ロードバランサ配下に複数インスタンスを配置できます。WebSocketサーバーはスケールアウト時にクライアントがどのノードにも接続し得るため、RedisなどでPub/Subを実装し全ノードにメッセージを拡散する機構を導入します。データベースはNotionが行ったようにシャーディング戦略で対応します ￼。具体的にはワークスペースIDやページIDのハッシュで複数DBに振り分け、アプリからはシャードルーティングを透過的に行う形にします。MVPでは必要ありませんが、スケール設計は念頭に置きます。
	•	パフォーマンス要求: リアルタイム性が重視される機能では低レイテンシが求められます。目標として、通常のブロック編集操作は他クライアントに <200ms で反映、ページロードは <1秒 で完了を目指します。WASM SQLiteのような高度なキャッシュはMVPでは不要ですが、簡易キャッシュ（例えばページロード時に複数APIをまとめて取得しRTTを減らす等）は入れます。将来的に遅延が問題になる部分（検索や大量データ処理など）はバックグラウンドワーカーを導入したり、アルゴリズム改善を検討します。なお、Notionがブラウザ版でSQLiteキャッシュによりページ遷移を20%高速化した事例もあります ￼が、まずはシンプルに実装しボトルネック分析後に対応します。
	•	セキュリティ: 認証認可で述べたこと以外にも、以下に留意します:
	•	XSS/CSRF対策: 入力されたコンテンツ（ブロックテキストなど）は表示時に適切にエスケープします（特にコードブロック内など除き）。またAPIはJWTによる認証でCSRFを防ぎますが、万全を期すならばSameSiteクッキーやCSRFトークンも検討します。
	•	SQLインジェクション: ORMまたはプレースホルダ付きSQLを使い、文字列連結でクエリを組み立てないことで対策します。
	•	権限昇格防止: サーバーサイドで全APIにおいて、ユーザーが操作対象のリソースに適切な権限を持つことをチェックする処理を統一的に行います（Security Gateの設置）。
	•	データ暗号化: 通信はHTTPS必須とし、サーバー・DB間も環境によってはSSL設定します。DB上のデータは基本平文で保持しますが、機微情報（将来的にユーザープレーンテキストとか）あれば暗号化検討します。
	•	依存ライブラリの脆弱性: npmやDockerイメージのセキュリティアップデートを定期的にあてます。CIで脆弱性スキャンを走らせ重大なものはデプロイ前に検知します。
	•	バックアップ: ユーザーの大切な情報を扱うため、定期バックアップを設定します。Postgresの場合、1日1回の全体ダンプやWALアーカイブによるポイントインタイムリカバリを構成します。小規模ならpg_dumpで十分ですが、クラウドRDSを利用するなら自動スナップショットを有効化します。バックアップデータの保存先は異なるストレージ（例: S3）で、世代管理し、データ破損時はそこから復旧できるようにします。
	•	マイグレーション戦略: スキーマ変更等は、コードと同期して適用できるようマイグレーションツール（例: Prisma Migrate, Flyway）を導入します。バージョン管理されたDDLを用意し、デプロイ時に自動で migrate されるようCI/CDに組み込みます。開発中もローカルでmigrateを適用し、データ破壊を伴う変更は極力避けます（どうしても必要な場合はバックアップ取得してから実施）。
	•	可用性: MVPフェーズではシングルインスタンス構成のため、障害が起きればダウンタイムが発生します。致命的な問題ではありませんが、今後ユーザー増に応じて冗長構成を整えます。サーバーはラウンドロビンで複数起動、DBはマスタスレーブ（プライマリ・リードレプリカ）構成にし、自動フェイルオーバーを設定します。またデプロイ時にBlue-Greenデプロイ等を行い、アップデートによるダウンも極力短くします。
	•	レート制限 & DDoS対策: 悪意のアクセスや誤操作による過負荷を防ぐため、APIレートリミットを導入します。例えば1つのIPアドレスからの/auth/login連続試行は5回/分まで、/pages閲覧は100回/分まで等、エンドポイント毎に設定します。実装はExpressの場合ミドルウェア(例えばexpress-rate-limit)で簡単に可能です。さらに、異常なアクセス（大量の404や明らかなスキャニング）があったIPは一時的にブロックする仕組みも入れます。DDoS対策としては、CDNやWAF(クラウドフレア等)の利用を検討します。小規模サービスではまずそこまで必要ないですが、シンプルなレイヤー4/7攻撃はNGINXレベルで制限できます（例えば同一IPからのコネクション数制限）。

以上の非機能設計により、MVPと言えど一定の信頼性と安全性を確保したサービスを提供します。Notion本家は大規模化に伴いデータレイク構築などスケーラビリティ課題に取り組んでいますが ￼ ￼、本プロダクトも将来的にはそうしたフェーズに備えて土台を作っておきます。まずは堅実な非機能要件充足に努め、ユーザーが安心して使えるプロダクトを目指します。

13. テスト戦略★

品質を担保するためのテスト戦略を定めます。単体テストから結合・E2Eテストまで多層的に実施し、またCIパイプラインで自動化します。目標は重要ロジックの**単体テストカバレッジ80%**以上を確保し、リグレッションを防ぐことです。
	•	単体テスト (ユニットテスト):
コード上の最小単位（関数やクラス）に対するテストです。主にドメインロジック部分（例: パーミッション判定関数、ブロックツリー操作関数、CRDTマージ関数など）を対象とします。TypeScriptではJestもしくは軽量なVitestを使用します。例えば、ブロック階層構造変更の関数に対し、期待通り親・子の関係が更新されるか、境界条件（先頭ブロックをアウトデントしたら何も起きない等 ￼）を確認します。またPermissionチェック関数について、様々な組み合わせ（ページ所有者、編集権のみのユーザー、ゲストなど）で正しい真偽値を返すかテストします。モックを活用しつつDBアクセスを含まない純粋ロジックを中心に行います。
	•	結合テスト (インテグレーションテスト):
複数モジュールが連携する部分をテストします。例えば、APIコントローラとDBを実際に繋いで、POST /blocksエンドポイントに対しブロックがDBに保存され、レスポンスが正しく返るかを確認します。これにはテスト用に軽量なSQLiteメモリDBやDockerでPostgresを立ち上げて行います。認証が必要なAPIについてはテスト用JWTを発行してヘッダ付与するなどして実施します。リアルタイムについても、WebSocket接続を擬似し、サーバーにメッセージを送り別のクライアントモックが受け取る流れをテストします。結合テストはJestでスイートを組み、npm scriptからjest --testPathPattern=integration等で分類実行します。
	•	E2Eテスト (エンドツーエンドテスト):
システム全体を起動し、実際のブラウザ操作を自動化して期待動作を検証します。PlaywrightやCypressといったE2Eテストフレームワークを利用します。例えば:
	•	「ログインして新規ページを作成し、タイトルを入力して保存。サイドバーにそのページが表示され、再読み込みしても残っている」
	•	「2つのブラウザセッションを開き、片方でブロックを編集したらもう片方にリアルタイム反映される」
	•	「権限のないユーザーで特定ページURLにアクセスしたらエラー表示される」
などのシナリオを自動化します。これにより、ユーザ視点での一連の機能がちゃんと繋がっているか検証できます。E2Eは時間がかかるため、CIでは基本的なシナリオのみ実行し、詳細は開発中に手動or必要時に回す方針です。
	•	コード品質チェック (Lint):
コードの一貫性とバグ防止のため、エーリンターとフォーマッターを導入します。選定としては、近年注目のBiomeを使用します。BiomeはESLint+Prettierに代わるRust製の高速な統合ツールで、JS/TS/JSON/GraphQL等に対応します ￼。npm run lintでBiomeを走らせ、文法エラーやスタイル違反を検出します。例えば未使用変数、型の不整合、セキュリティ上よろしくないコーディング（dangerouslySetInnerHTMLの使用など）に警告を出します。CIではlintがパスしないとビルドに進めないようにします。BiomeはPrettier互換のフォーマットも持つため、自動整形も適用し、チーム内でコードスタイルを統一します ￼。
	•	ビルド & 型チェック:
TypeScriptのコンパイル（tsc）による型チェックもCIで実行します。型エラーは即座に修正し、runtimeでの不具合を未然に防ぎます。またNext.jsのビルド（next build）も走らせ、静的ビルドエラーがないことを確認します。UIコンポーネントの単体テストも可能なら含めます（React Testing Libraryを用いて、特定コンポーネントにプロップを与えた時正しくDOMが出力される等）。
	•	テストカバレッジ:
単体テストと結合テストにはカバレッジ収集を有効にします。Line coverage, Branch coverageを計測し、目標として**80%**以上を設定します（カバレッジレポートをCI出力し、閾値未達ならfailさせる）。重要度の高いモジュール（例えば権限周りやコラボ周り）は可能な限り100%近くカバーします。一方、UIの見た目などテストしづらい箇所は無理にテストせず、人間の目によるレビューに任せます。
	•	CI/CDパイプライン:
GitHubなどのリポジトリにプッシュ時、自動で上記のテスト・チェックを走らせます。具体的には:
	1.	Lint & Formatチェック（Biome）
	2.	ビルドと型チェック
	3.	単体テスト実行（–coverage）
	4.	結合テスト実行
（E2Eテストは本番リリース前や長期ブランチでのみ任意実行）
これらステップが全て成功した場合のみ、pull requestをマージ可能にするGateを設定します。CD（デプロイ）もテスト通過後自動化することで、ヒューマンエラーを減らします。
	•	テストデータ:
テスト用にシードデータを用意し、疑似的なユーザーやページを自動投入してからテストを行います。例えば「Alice (admin), Bob (member), Charlie (guest)」といったユーザーと、公開・非公開それぞれのページをあらかじめ登録し、様々なケースを試せるようにします。モックが難しいE2Eでは実際の認証も必要になるので、テストユーザー用のOAuthクレデンシャルやバイパス手段を設けます。

テスト戦略により、コードの回帰を素早く検出し、安心してリファクタや機能追加が行える体制を築きます。Notion開発チームも品質に注意を払い、大規模リファクタ（パフォーマンス改善など）をユーザー影響なく実施してきました ￼。本プロダクトも自動テスト網に支えられつつアジャイルに進化できるよう、この戦略を徹底します。

14. ロードマップ & マイルストーン★

MVPリリースまでの開発ロードマップをフェーズ分割して示します。Skeleton段階から始めて徐々に機能を揃え、最終的にチーム利用可能な完成版(MVP)を目指します。その後の拡張も視野に入れ、マイルストーンを設定します。
	•	M0: Skeleton (設計骨組み, 1ヶ月)
	•	目的: アプリの最小構成を作り動作確認する。
	•	内容: プロジェクトのセットアップ（Next.js, Express, Postgres環境構築）。基本的なページ表示の流れをSkeleton実装。具体的には認証なしで固定のダミーページを表示できるようにする。ブロックエディタはテキスト1種類のみサポート。データはインメモリor簡易JSONファイルで仮置きでも可。
	•	完了の定義: 「Hello World」ページがブラウザで表示でき、ブロックを追加・編集してリロードしても残っている（DB保存されている）状態になる。ディレクトリ構造・CIパイプラインの雛形も整備。
	•	M1: MVP (全コア機能実装, +2〜3ヶ月)
	•	目的: 前述のMVP要件をすべて満たす状態にする。一通りの主要ユースケースが実現可能。
	•	内容: 認証(OAuth+JWT)導入、ページ・ブロックCRUD API実装、フロントエンドからAPI接続、ブロックエディタで複数ブロックタイプ対応、リアルタイム同期(基本実装)、権限管理(ページ共有UIとACLチェック)実装。テスト整備。本番相当環境での動作確認。
	•	完了の定義: チーム内でこのMVPを使ってドキュメント作成・共有が問題なく行える。具体的には: 2人以上が同じページをリアルタイム編集し、編集ロスなく同期される。ページをゲスト共有し、ゲストは閲覧のみで編集不可となる。サーバーリスタートしてもデータ永続化OK。主要バグが潰され安定している。
	•	M2: Betaリリース (性能改善とUX向上, +1ヶ月)
	•	目的: チーム外部のユーザーにも試験利用してもらえる品質・性能に高める。
	•	内容: パフォーマンスチューニング（大きなページでのストレステスト、DBインデックス最適化）、UI磨き（ドラッグ&ドロップ操作性向上、細かなスタイル調整、モバイルブラウザ対応の検討）、セキュリティ監査（脆弱性スキャン実施）、モニタリング・アラート導入。ドキュメント（ユーザーガイド簡易版）作成。
	•	完了の定義: 想定ユーザー（5〜10人規模チーム）で1日に100ページ以上運用しても問題なく、明らかなUXの不満がない。ページロード時間や操作遅延が許容範囲に収まっている。外部有識者によるセキュリティレビューで致命的問題なし。
	•	M3: 公開リリース (フィードバック反映, +1ヶ月)
	•	目的: ベータテストの結果を踏まえ、改善と機能追加を行い正式版リリース。
	•	内容: ユーザーフィードバックで要望の高かった改善を実施。例: 検索機能の追加（全ページテキスト検索）、コメント機能の追加、ページ履歴参照機能の追加など。大きな新機能は避け、MVP範囲内の使い勝手向上に注力。課金や管理機能（メンバー招待管理UI等）もこの段階で検討開始。
	•	完了の定義: プロダクトが十分使いやすく安定し、正式にチーム利用を推奨できる。既知の重大バグがない状態。ドキュメントやサポート体制が整い、ユーザーを受け入れ可能。
	•	将来のフェーズ:
M3以降はプロダクトの方向性次第ですが、考えられるフェーズ:
	•	M4: スケーリングフェーズ: ユーザー数増加に合わせ、シャーディング導入やオフラインモード本格対応(CRDT完成)などスケーラビリティ強化を実施。Notionが20→200億ブロックに対応したような大規模化対応 ￼ ￼。
	•	M5: 差別化機能フェーズ: 他社との差別化となる機能（AIアシスタント、プラグインエコシステム、より高度なワークフロー自動化）を追加し、プロダクト価値向上を狙う。
	•	M6: エンタープライズフェーズ: 大企業導入向けにSSO/SAML対応、監査ログ、アクセス権テンプレート、データ地域指定などエンタープライズ機能を追加。

各フェーズのマイルストーンは上記の**完了の定義(Exit Criteria)**に基づき評価します。特にM1(MVP)完了時にはプロダクトの核が出来上がっていることを重視します。以降のフェーズではユーザビリティや規模対応といった観点での成熟を図ります。

ロードマップはあくまで予定であり、ユーザーからのフィードバックや開発上の発見に応じて柔軟に変更します。しかし**「Skeleton→MVP→Polish→Release」**の大きな流れは維持し、段階的にリスクを減らしながら開発する方針です。

15. リスク & 想定課題★

プロジェクト遂行にあたり予想されるリスクや技術的課題を整理し、対策・緩和策を検討します。
	•	技術的不確実性: ブロックエディタ実装難易度
内容: ブロックエディタ（特にドラッグ＆ドロップや高度なテキスト操作）は実装が複雑で、バグが入り込みやすい領域です。ProseMirror等の高度なライブラリを使っても独自要件実現にカスタム実装が必要になります。
リスク: 開発見積もり以上に時間を要し、MVP期限に間に合わない可能性があります。またUXが期待通りにならずユーザー不満が残る恐れも。
対策: 初期はシンプルな実装から開始し、複雑な操作（ドラッグ入れ子移動など）は段階的に対応します。まずは基本のテキスト編集とブロック追加・削除を安定させ、その後ドラッグ操作を追加するなど分割統治します。また既存OSSやコミュニティの知見を活用し、例えばTiptapの例やサンプルをベースにすることで実装コストを下げます。難所はテスト（特にE2E）を充実させバグ混入を検知しやすくします。
	•	リアルタイム同期: CRDT実装コストとデータ整合性
内容: CRDT（Yjs）を導入することでオフライン対応やスムーズなマージを狙いますが、その統合は容易ではありません。CRDTを中途半端に実装すると、かえってデータ不整合やメモリリークなどの問題を招く可能性があります。特に大量編集時のパフォーマンスや、ストレージへの反映戦略など検討項目が多いです。
リスク: CRDTの実装に時間を取られすぎ、他機能に影響が出る。あるいは不具合により共同編集時にデータロスが発生する。最悪CRDTの不備でオフライン編集が破綻する。
対策: 段階的アプローチとします。まずMVPではオフライン非対応と割り切り、単純なLast-Write-Wins方式で実装し、各操作にバージョンを持たせサーバー側が直近の変更を正とみなす方法を取ります ￼。これにより実装をシンプルに保ちます。その上で、CRDTに関する部分は並行してR&Dを進め、安定性が確認でき次第置き換える計画です。Yjsについては公式ドキュメントやコミュニティ支援 ￼を活用し、事前にプロトタイプで挙動検証します。また、最悪CRDTを諦めOTへの切替（ライブラリ選定含め）も視野に入れ、固執しないようにします。
	•	パフォーマンス: ブロック数増大時の応答性低下
内容: ブロックモデルではドキュメントを細かく分割しているため、ページ内ブロック数が非常に多い場合（数千〜数万）、表示や検索に時間がかかる可能性があります ￼。特に検索で「異なるブロックにまたがるキーワード」がヒットしない問題は既知です ￼。
リスク: 大きなページを開くときに遅延が発生しユーザー体験を損ねる。またブロック単位検索の欠点によりユーザーが情報を見つけにくくなる恐れ。
対策: 表示についてはバーチャルスクロール技術を導入します。大量のブロックがある場合でも、画面に見える範囲のみDOM生成し、他はプレースホルダにすることでレンダリングコストを抑えます。検索については、単純な全文検索ではブロック粒度だと意図しない結果になる問題（Spaghetti Parmesan問題 ￼）に対処します。解決策として、検索クエリ中の複数単語が連続しなくてもブロックをまたいで近接して現れた場合はヒットさせる独自アルゴリズムを検討します ￼。具体的には、ページ単位で一旦全文構築してインデックスするアプローチや、検索時に隣接ブロックも連結してマッチングするなどです。パフォーマンス面のリスクは、早期に大規模データでのベンチマークを実施しボトルネックを突き止め改善を繰り返します。
	•	データ一貫性: トランザクション管理と競合
内容: 複数ユーザーが同時に同じページやデータベースを更新する際、サーバー側で競合が起きる可能性があります。例えば、同時に2人がページに別のブロックを追加した場合、contentの順序や親参照の一貫性が保たれるか。
リスク: 最悪の場合データベースの不整合（contentリストに重複IDや抜けが生じる等）が発生する恐れ。ユーザー視点では変更の一部が反映されない/消えるといった不具合になる。
対策: サーバー側でのトランザクション境界を厳密にします。Notionでも全変更はサーバーで一括バリデーションしてからコミットする設計です ￼。本クローンでも単一APIリクエスト内の複数変更（例えばブロック移動で親更新＋自ブロックのparent変更など）はトランザクションで囲んで処理し、一部だけ成功することのないようにします。競合については、データベースの一意制約や外部キーで検知できるものは即エラーにしてクライアントでリトライ処理します。content順序は、衝突が起きにくいようUI側で工夫します（例えば複数人が同時にソート順を入れ替える状況は稀）。必要なら、サーバーが操作をシリアライズして適用するキュー機構（MessageQueueで順次処理）を導入しますが、MVP段階ではパフォーマンスとトレードオフなので様子を見ます。
	•	スケールと負荷: インフラコストとDDoS
内容: ユーザー数やデータ量増大に伴い、インフラのスケールが必要になりますが、当初モノリシック設計のため限界があります。また悪意あるアクセス集中でサービスダウンのリスクも。
リスク: 想定以上に利用が広がった際に応答が極端に遅くなる、あるいはサーバーダウンする可能性。特にフロントとリアルタイムWSが同プロセスだと負荷集中で全滅する危険。
対策: 早めに負荷テストを行い、1台あたりのハンドル可能ユーザー数を把握します。縦方向（スケールアップ）で一旦は耐えられるよう、余裕あるスペックのマシンで運用します（例えば8CPU, 16GB RAMなど）。将来的にはスケールアウト計画を実施します（前述ロードマップM4あたり）。それまでにコードをスケールアウトしやすいよう分割（例えばWS処理を分離可能にしておく等）しておきます。DDoS対策は、クラウドフレアなどのCDN/WAFサービスを利用検討します。アプリケーション側でもレートリミット設定 ￼や、検知した攻撃IPの早期シャットアウト（ファイアウォール設定）を自動化します。インフラコストについては、必要になった時点でリソース追加投入でしのぎ、並行してコード最適化（例: 不要なメモリ保持を削減して同一マシンでより多く捌く）を進めます。
	•	開発リソース: 一人開発のボトルネック
内容: 当プロジェクトはエンジニア一名で実装・テストを行う前提です。そのため開発リソースは限られ、人的ミスや見落としリスクが増えます。特にフロントからバックエンドまで広範囲をカバーする必要があり、負荷が高いです。
リスク: スケジュール遅延や、テスト不足による欠陥見逃し。長時間労働による品質低下。属人化による将来保守困難。
対策: 優先順位付けを徹底します。MVPのゴールを常に意識し、クリティカルでない機能は大胆に後回しorカットします。設計段階で盛り込んだ内容も、実装が難航したら簡易化してスコープ調整します。テストについてはCIを駆使し、自動で可能な限り担保することで人的負担を軽減します。またドキュメント（本書など）を充実させ、万一他メンバー増員時にも素早くキャッチアップできるようにします。進捗は短いイテレーションで管理し、早め早めに問題を顕在化させ対処します。
	•	その他リスク: UX面では「Notion比較で劣る部分へのユーザーの不満」、プロジェクト面では「要件変更への対応」なども考えられます。これらはユーザーヒアリングやステークホルダーとの定期ミーティングで早期に把握し、計画に織り込むようにします。

リスクは完全になくすことはできませんが、事前に認識し対策を講じておくことで影響を最小化します。Notionチームも例えばEvernoteの反省（悪いバックエンド設計が共有機能開発を困難にした等）から学んでブロックモデルを選択した経緯があります ￼ ￼。本プロダクトでも既存知見を活用しつつ、リスクをコントロールして成功に近づけます。

16. 参考資料 & 決定履歴★

本プロジェクトに関連して調査した情報源、および主要なアーキテクチャ上の決定(ADR: Architecture Decision Record)を一覧します。

参考資料（リンク集）：
	•	Notion公式技術ブログ: 「The data model behind Notion’s flexibility」 ￼ ￼ ￼など – Notionのブロックモデルや権限設計についてエンジニアが解説した記事。設計の指針として大いに参考にした。
	•	Notion公式技術ブログ: 「How we sped up Notion in the browser with WASM SQLite」 ￼ – クライアントキャッシュ戦略についての知見。MVPでは導入しないが将来の性能改善ネタとして参考。
	•	Hacker Newsスレッド: 「You don’t need a CRDT to build a collaborative experience」 ￼ ￼ – Notionエンジニアのコメントがあり、同社が当初CRDT無しで協調編集していた背景と今後CRDT導入予定であることが記されている。
	•	ByteByteGoブログ: 「Storing 200 Billion Entities: Notion’s Data Lake Project」 ￼ ￼ – Notionが膨大なブロックをPostgresシャーディングでスケールさせた事例。将来のスケーラビリティ検討に参照。
	•	DhiWiseブログ: 「Build Your Own Notion App: A Comprehensive Guide」 ￼ ￼ – Notionクローン構築のポイントをまとめた記事。技術スタックの選択肢やC.R.A.F.T戦略（Canvas, Real-time, API, Frameworks, Trust）など示唆を得た。
	•	Thomas Frankブログ: 「Notion Sharing & Permissions: The Ultimate Guide」 ￼ ￼ – Notionの共有と権限に関する詳細なユーザー向け解説。ロールや権限継承について設計時に参照した。
	•	StackOverflow質問: 「Choosing DB model for an app similar to Notion…」 ￼ ￼ – ブロックベース vs ドキュメントベースの議論。ブロックモデル採用のメリット・デメリット理解に役立てた。
	•	Yjs公式Docs: 「Introduction」 ￼ ￼ – CRDTアルゴリズム（Yjs）の概要と特性について確認。自動マージやスケーラビリティに関する部分を引用した。
	•	Biome公式: 「Biome GitHub README」 ￼ – 新世代のリンタ・フォーマッタBiomeの情報源。テスト戦略のLint部分に採用する際に参照。

主要決定履歴 (ADR):
	1.	ADR: ブロックモデルを採用 – 決定: アプリの情報構造はNotion同様ブロックを最小単位とするモデルにした。【理由】柔軟な情報構成と将来的な拡張性のため。従来型の文書モデルではリアルタイム編集や機能追加が難しく、Evernoteの例から学んだ ￼ ￼。ブロックモデル採用により、細粒度のコントロールと再利用が可能になる ￼。
	2.	ADR: モノリシックアーキテクチャで開始 – 決定: 初期段階ではサーバーはモノリス構成（Next.js+NodeでRESTとWSを一体で）とする。【理由】開発速度とシンプルさを優先。Notionも初期は1DBで始め徐々にスケールアウトした ￼ ￼。「まずシンプルに作り必要に応じ賢くスケール」という哲学 ￼に則った。
	3.	ADR: リアルタイム同期にCRDT (Yjs) を採用 – 決定: 共同編集の衝突解決にCRDT技術を組み込む方針とした（最初は限定利用、段階移行）。【理由】オフライン編集やサーバ依存脱却のため。【他案】OTも検討したが、クライアント主導でのマージ容易性からCRDTを選択。【根拠】Notion自身オフラインの課題からCRDT移行を決めている ￼、またYjsは実績ある実装 ￼。
	4.	ADR: Next.js (React/TypeScript) + Postgres技術スタック – 決定: フロントはNext.js、サーバーはNode/Express、DBはPostgresに決定。【理由】TypeScriptで統一でき開発効率が高く、ReactはリッチUIに必須。PostgresはNotion本家も採用しブロックの大量格納実績がある ￼。リアルタイムはWebSocket（将来はサービス分離）利用とし、実装の容易さと拡張性バランスを考慮した。
	5.	ADR: REST API採用 – 決定: クライアントサーバ通信はRESTful APIで構築。【理由】開発者に馴染み深く、OpenAPIで明確に定義できる。GraphQLは柔軟だが初期実装コストと過剰性を懸念し見送り。Notionの外部APIもRESTなのでそれに倣った ￼。
	6.	ADR: 権限はページ単位ACL+ワークスペースロール – 決定: Notion同様の権限モデルを採用。ページごとに閲覧/編集権を付与し、ワークスペースにオーナー/メンバー/ゲストのロール区分。【理由】細かすぎない制御粒度でユーザー理解しやすく、実装もシンプル。ブロック単位の個別権限は設けず、管理コストを抑える（必要なら将来検討）。
	7.	ADR: Biome導入 – 決定: コード品質ツールとしてBiomeを使用する。【理由】統合されたLint+Formatツールで、Rust製の高速性もあり開発体験向上。ESLint+Prettierの組合せを省略して設定も簡素化できる ￼。
	8.	ADR: テストファースト方針 – 決定: ユニットテストを重視し、重要ロジックは実装前または実装直後にテストを書いて品質担保する。【理由】一人開発でありレビュー機構が限られるため、自動テストによるセルフレビュー体制を築く必要があるため。カバレッジ目標80%を設定しCIで常に確認。

(この他、小さな決定事項は随時プロジェクトリポジトリのADRフォルダにMarkdown記録する運用とします。)

18. 付録★

用語集:
	•	ブロック (Block): ノート内の最小コンテンツ単位。段落、画像、リストアイテム、ページ等すべてがブロックとして扱われる ￼。
	•	ページ (Page): ブロックの一種であり、他のブロックを子として含むことができる。ドキュメント1つに相当。ワークスペース内に階層構造で存在する。
	•	データベース (Database): 複数のページを表形式等で管理する特殊なページ。ページに追加のプロパティ（列）を付与した集合。Notionのデータベース。
	•	ワークスペース (Workspace): ユーザーグループが共同で利用する空間。内部にページ群を持つ。Notionでは一つの会社や組織に対応。
	•	CRDT: Conflict-Free Replicated Data Type。分散システムでデータの最終整合性をとるデータ構造。各ノードが自由に更新し後でマージしても矛盾が無い特徴を持つ ￼。
	•	OT: Operational Transformation。リアルタイム協調編集で用いられる手法。操作（挿入/削除）を他クライアントで適用可能なよう変換する。Google Docs等で採用。
	•	UUID: Universal Unique IDentifier。各ブロックやページの一意識別子として使用。v4（ランダム）を使用 ￼。
	•	LWW: Last-Writer-Wins。一番新しい更新を正として競合を解決する戦略 ￼。単純だがオフラインで競合が起きた場合に意図しない結果を招くことがある ￼。
	•	ADR: Architecture Decision Record。設計上の重要な判断とその理由を記録する文書。

UIワイヤーフレーム:
（テキストで簡易記述）
	•	メイン画面: 画面左にサイドバー（ワークスペース名、ページツリー、共有セクション、+ボタン）、画面上部に簡易ヘッダ（現在のページタイトルの表示と共有ボタン、ユーザーアイコン）、画面右はページ内容エリア。ページエリアでは各ブロックがカード状に連なり、ブロック左に＋ボタンとドラッグハンドル（⋮⋮）が表示される。
	•	共有ダイアログ: ページ右上の「Share」ボタン押下でモーダル表示。ページ公開範囲切替（公開リンクOff/On、ワークスペースメンバー権限）と、個別に人を招待する入力欄（名前/メール）+ 権限ドロップダウンがある。現在の共有相手一覧も表示され、権限変更や削除（×）が可能。
	•	データベースビュー: ページ内容エリアがテーブル形式に。上部にプロパティの追加・フィルタ/ソートUI、各行はページリンクとして表示（クリックでそのページ詳細に飛ぶ）。行の追加は最下行の+ボタンから。

省略した詳細図:
	•	ER図: Users, Pages, Blocks等のリレーションを図示したもの（テキスト説明に留めたが、図が必要ならPlantUML/ERDツールで作成予定）。
	•	シーケンス図視覚化: 項目10で文章で示したフローは、本来時系列図にした方が分かりやすい。例えば、「ユーザーAとBが同時編集」の図。PlantUMLでsequence図を書くか、手書き図を用意可能。
	•	コンポーネント図: 項目7で述べたアーキテクチャをUMLコンポーネント図で示すと、Client、WebServer、DB、AuthProvider、MessageStore間の関係が視覚化できる。簡易図としては：

```plantuml
[Browser Client] -- (HTTP/REST) --> [Web Server] -- (SQL) --> [PostgreSQL]
[Browser Client] -- (WebSocket) --> [Web Server] 
[Web Server] -- (OAuth) --> [Google API]
```

のようなイメージ。

以上、付録として補足情報をまとめました。本設計書をもとに、実装段階では適宜詳細設計をブラッシュアップし、必要なら追加の図やサンプルコードを作成していきます。